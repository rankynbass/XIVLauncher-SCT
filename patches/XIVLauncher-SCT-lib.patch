diff --git a/src/.editorconfig b/src/.editorconfig
new file mode 100644
index 00000000..0ae30cf9
--- /dev/null
+++ b/src/.editorconfig
@@ -0,0 +1,147 @@
+root = true
+# top-most EditorConfig file
+
+[*]
+charset = utf-8
+
+end_of_line = lf
+insert_final_newline = true
+
+# 4 space indentation
+indent_style = space
+indent_size = 4
+
+# disable redundant style warnings
+
+# Microsoft .NET properties
+csharp_indent_braces = false
+csharp_new_line_before_catch = true
+csharp_new_line_before_else = true
+csharp_new_line_before_finally = true
+csharp_new_line_before_members_in_object_initializers = false
+csharp_new_line_before_open_brace = all
+csharp_preferred_modifier_order = public, private, protected, internal, new, abstract, virtual, sealed, override, static, readonly, extern, unsafe, volatile, async:suggestion
+csharp_style_var_elsewhere = true:suggestion
+csharp_style_var_for_built_in_types = true:suggestion
+csharp_style_var_when_type_is_apparent = true:suggestion
+dotnet_code_quality_unused_parameters = non_public
+dotnet_naming_rule.event_rule.severity = warning
+dotnet_naming_rule.event_rule.style = upper_camel_case_style
+dotnet_naming_rule.event_rule.symbols = event_symbols
+dotnet_naming_rule.private_constants_rule.severity = warning
+dotnet_naming_rule.private_constants_rule.style = upper_camel_case_style
+dotnet_naming_rule.private_constants_rule.symbols = private_constants_symbols
+dotnet_naming_rule.private_instance_fields_rule.severity = warning
+dotnet_naming_rule.private_instance_fields_rule.style = lower_camel_case_style
+dotnet_naming_rule.private_instance_fields_rule.symbols = private_instance_fields_symbols
+dotnet_naming_rule.private_static_fields_rule.severity = warning
+dotnet_naming_rule.private_static_fields_rule.style = lower_camel_case_style
+dotnet_naming_rule.private_static_fields_rule.symbols = private_static_fields_symbols
+dotnet_naming_rule.private_static_readonly_rule.severity = warning
+dotnet_naming_rule.private_static_readonly_rule.style = upper_camel_case_style
+dotnet_naming_rule.private_static_readonly_rule.symbols = private_static_readonly_symbols
+dotnet_naming_style.lower_camel_case_style.capitalization = camel_case
+dotnet_naming_style.on_upper_camel_case_style.capitalization = pascal_case
+dotnet_naming_style.on_upper_camel_case_style.required_prefix = On
+dotnet_naming_style.upper_camel_case_style.capitalization = pascal_case
+dotnet_naming_symbols.event_symbols.applicable_accessibilities = *
+dotnet_naming_symbols.event_symbols.applicable_kinds = event
+dotnet_naming_symbols.private_constants_symbols.applicable_accessibilities = private
+dotnet_naming_symbols.private_constants_symbols.applicable_kinds = field
+dotnet_naming_symbols.private_constants_symbols.required_modifiers = const
+dotnet_naming_symbols.private_instance_fields_symbols.applicable_accessibilities = private
+dotnet_naming_symbols.private_instance_fields_symbols.applicable_kinds = field
+dotnet_naming_symbols.private_static_fields_symbols.applicable_accessibilities = private
+dotnet_naming_symbols.private_static_fields_symbols.applicable_kinds = field
+dotnet_naming_symbols.private_static_fields_symbols.required_modifiers = static
+dotnet_naming_symbols.private_static_readonly_symbols.applicable_accessibilities = private
+dotnet_naming_symbols.private_static_readonly_symbols.applicable_kinds = field
+dotnet_naming_symbols.private_static_readonly_symbols.required_modifiers = static,readonly
+dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:suggestion
+dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:suggestion
+dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:suggestion
+dotnet_style_predefined_type_for_member_access = true:suggestion
+dotnet_style_require_accessibility_modifiers = for_non_interface_members:suggestion
+dotnet_style_parentheses_in_other_operators = always_for_clarity:silent
+dotnet_style_object_initializer = false
+dotnet_style_qualification_for_event = true:suggestion
+dotnet_style_qualification_for_field = true:suggestion
+dotnet_style_qualification_for_method = true:suggestion
+dotnet_style_qualification_for_property = true:suggestion
+csharp_space_between_method_call_empty_parameter_list_parentheses = false
+csharp_space_between_method_call_parameter_list_parentheses = false
+csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
+csharp_space_between_empty_square_brackets = false
+csharp_space_before_semicolon_in_for_statement = false
+csharp_space_before_open_square_brackets = false
+csharp_space_before_comma = false
+csharp_space_after_keywords_in_control_flow_statements = true
+csharp_space_after_comma = true
+csharp_space_after_cast = false
+csharp_space_around_binary_operators = before_and_after
+csharp_space_between_method_declaration_name_and_open_parenthesis = false
+csharp_space_between_method_declaration_parameter_list_parentheses = false
+csharp_space_between_parentheses = none
+csharp_space_between_square_brackets = false
+
+# ReSharper properties
+resharper_align_linq_query = true
+resharper_align_multiline_argument = true
+resharper_align_multiline_calls_chain = true
+resharper_align_multiline_expression = true
+resharper_align_multiline_extends_list = true
+resharper_align_multiline_for_stmt = true
+resharper_align_multline_type_parameter_constrains = true
+resharper_align_multline_type_parameter_list = true
+resharper_apply_on_completion = true
+resharper_auto_property_can_be_made_get_only_global_highlighting = none
+resharper_auto_property_can_be_made_get_only_local_highlighting = none
+resharper_autodetect_indent_settings = true
+resharper_braces_for_ifelse = required_for_multiline
+resharper_can_use_global_alias = false
+resharper_csharp_align_multiline_parameter = true
+resharper_csharp_align_multiple_declaration = true
+resharper_csharp_empty_block_style = multiline
+resharper_csharp_int_align_comments = true
+resharper_csharp_new_line_before_while = true
+resharper_csharp_wrap_after_declaration_lpar = true
+resharper_enforce_line_ending_style = true
+resharper_member_can_be_private_global_highlighting = none
+resharper_member_can_be_private_local_highlighting = none
+resharper_new_line_before_finally = false
+resharper_place_accessorholder_attribute_on_same_line = false
+resharper_place_field_attribute_on_same_line = false
+resharper_show_autodetect_configure_formatting_tip = false
+resharper_use_indent_from_vs = false
+
+# ReSharper inspection severities
+resharper_arrange_missing_parentheses_highlighting = hint
+resharper_arrange_redundant_parentheses_highlighting = hint
+resharper_arrange_this_qualifier_highlighting = none
+resharper_arrange_type_member_modifiers_highlighting = hint
+resharper_arrange_type_modifiers_highlighting = hint
+resharper_built_in_type_reference_style_for_member_access_highlighting = hint
+resharper_built_in_type_reference_style_highlighting = none
+resharper_foreach_can_be_converted_to_query_using_another_get_enumerator_highlighting = none
+resharper_foreach_can_be_partly_converted_to_query_using_another_get_enumerator_highlighting = none
+resharper_invert_if_highlighting = none
+resharper_loop_can_be_converted_to_query_highlighting = none
+resharper_method_has_async_overload_highlighting = none
+resharper_private_field_can_be_converted_to_local_variable_highlighting = none
+resharper_redundant_base_qualifier_highlighting = none
+resharper_suggest_var_or_type_built_in_types_highlighting = hint
+resharper_suggest_var_or_type_elsewhere_highlighting = hint
+resharper_suggest_var_or_type_simple_types_highlighting = hint
+resharper_unused_auto_property_accessor_global_highlighting = none
+csharp_style_deconstructed_variable_declaration = true:silent
+
+[*.{appxmanifest,asax,ascx,aspx,axaml,axml,build,c,c++,cc,cginc,compute,config,cp,cpp,cs,cshtml,csproj,css,cu,cuh,cxx,dbml,discomap,dtd,h,hh,hlsl,hlsli,hlslinc,hpp,htm,html,hxx,inc,inl,ino,ipp,js,json,jsproj,jsx,lsproj,master,mpp,mq4,mq5,mqh,njsproj,nuspec,paml,proj,props,proto,razor,resjson,resw,resx,skin,StyleCop,targets,tasks,tpp,ts,tsx,usf,ush,vb,vbproj,xaml,xamlx,xml,xoml,xsd}]
+indent_style = space
+indent_size = 4
+tab_width = 4
+dotnet_style_parentheses_in_other_operators = always_for_clarity:silent
+
+[*.{yaml,yml}]
+indent_style = space
+indent_size = 2
+tab_width = 2
diff --git a/src/XIVLauncher.Common.Unix/Compatibility/CompatibilityTools.cs b/src/XIVLauncher.Common.Unix/Compatibility/CompatibilityTools.cs
index 8216526f..ffe33152 100644
--- a/src/XIVLauncher.Common.Unix/Compatibility/CompatibilityTools.cs
+++ b/src/XIVLauncher.Common.Unix/Compatibility/CompatibilityTools.cs
@@ -1,13 +1,12 @@
 ï»¿using System;
 using System.Collections.Generic;
-using System.Collections.Specialized;
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using System.Net.Http;
 using System.Threading.Tasks;
-using Serilog;
+using System.Net.Http;
 using XIVLauncher.Common.Util;
+using Serilog;
 
 #if FLATPAK
 #warning THIS IS A FLATPAK BUILD!!!
@@ -17,56 +16,46 @@ namespace XIVLauncher.Common.Unix.Compatibility;
 
 public class CompatibilityTools
 {
-    private DirectoryInfo toolDirectory;
+    private DirectoryInfo wineDirectory;
+    
     private DirectoryInfo dxvkDirectory;
 
     private StreamWriter logWriter;
 
-#if WINE_XIV_ARCH_LINUX
-    private const string WINE_XIV_RELEASE_URL = "https://github.com/goatcorp/wine-xiv-git/releases/download/8.5.r4.g4211bac7/wine-xiv-staging-fsync-git-arch-8.5.r4.g4211bac7.tar.xz";
-#elif WINE_XIV_FEDORA_LINUX
-    private const string WINE_XIV_RELEASE_URL = "https://github.com/goatcorp/wine-xiv-git/releases/download/8.5.r4.g4211bac7/wine-xiv-staging-fsync-git-fedora-8.5.r4.g4211bac7.tar.xz";
-#else
-    private const string WINE_XIV_RELEASE_URL = "https://github.com/goatcorp/wine-xiv-git/releases/download/8.5.r4.g4211bac7/wine-xiv-staging-fsync-git-ubuntu-8.5.r4.g4211bac7.tar.xz";
-#endif
-    private const string WINE_XIV_RELEASE_NAME = "wine-xiv-staging-fsync-git-8.5.r4.g4211bac7";
-
     public bool IsToolReady { get; private set; }
 
     public WineSettings Settings { get; private set; }
 
-    private string WineBinPath => Settings.StartupType == WineStartupType.Managed ?
-                                    Path.Combine(toolDirectory.FullName, WINE_XIV_RELEASE_NAME, "bin") :
-                                    Settings.CustomBinPath;
-    private string Wine64Path => Path.Combine(WineBinPath, "wine64");
-    private string WineServerPath => Path.Combine(WineBinPath, "wineserver");
+    public DxvkSettings DxvkSettings { get; private set; }
 
-    public bool IsToolDownloaded => File.Exists(Wine64Path) && Settings.Prefix.Exists;
+    public bool IsToolDownloaded => File.Exists(Settings.WinePath) && Settings.Prefix.Exists;
 
-    private readonly Dxvk.DxvkHudType hudType;
+    public bool IsFlatpak { get; }
+    
     private readonly bool gamemodeOn;
-    private readonly string dxvkAsyncOn;
 
-    public CompatibilityTools(WineSettings wineSettings, Dxvk.DxvkHudType hudType, bool? gamemodeOn, bool? dxvkAsyncOn, DirectoryInfo toolsFolder)
+    private Dictionary<string, string> extraEnvironmentVars;
+
+    public CompatibilityTools(WineSettings wineSettings, DxvkSettings dxvkSettings, bool? gamemodeOn, DirectoryInfo toolsFolder, bool isFlatpak, Dictionary<string, string> extraEnvVars = null)
     {
         this.Settings = wineSettings;
-        this.hudType = hudType;
+        this.DxvkSettings = dxvkSettings;
         this.gamemodeOn = gamemodeOn ?? false;
-        this.dxvkAsyncOn = (dxvkAsyncOn ?? false) ? "1" : "0";
 
-        this.toolDirectory = new DirectoryInfo(Path.Combine(toolsFolder.FullName, "beta"));
+        // These are currently unused. Here for future use. 
+        this.IsFlatpak = isFlatpak;
+        this.extraEnvironmentVars = extraEnvVars ?? new Dictionary<string, string>();
+
+        this.wineDirectory = new DirectoryInfo(Path.Combine(toolsFolder.FullName, "wine"));
         this.dxvkDirectory = new DirectoryInfo(Path.Combine(toolsFolder.FullName, "dxvk"));
 
         this.logWriter = new StreamWriter(wineSettings.LogFile.FullName);
 
-        if (wineSettings.StartupType == WineStartupType.Managed)
-        {
-            if (!this.toolDirectory.Exists)
-                this.toolDirectory.Create();
+        if (!this.wineDirectory.Exists)
+            this.wineDirectory.Create();
 
-            if (!this.dxvkDirectory.Exists)
-                this.dxvkDirectory.Create();
-        }
+        if (!this.dxvkDirectory.Exists)
+            this.dxvkDirectory.Create();
 
         if (!wineSettings.Prefix.Exists)
             wineSettings.Prefix.Create();
@@ -74,30 +63,79 @@ public class CompatibilityTools
 
     public async Task EnsureTool(DirectoryInfo tempPath)
     {
-        if (!File.Exists(Wine64Path))
+        if (Settings.IsProton)
         {
-            Log.Information("Compatibility tool does not exist, downloading");
-            await DownloadTool(tempPath).ConfigureAwait(false);
+            if (!File.Exists(Settings.WinePath))
+                throw new FileNotFoundException("Proton or runtime not found.");
+            IsToolReady = true;
+            EnsurePrefix();
+            return;
         }
 
+        if (!File.Exists(Settings.WinePath))
+        {
+            Log.Information($"Compatibility tool does not exist, downloading {Settings.DownloadUrl}");
+            await DownloadWine().ConfigureAwait(false);
+        }
         EnsurePrefix();
-        await Dxvk.InstallDxvk(Settings.Prefix, dxvkDirectory).ConfigureAwait(false);
+        
+        if (DxvkSettings.Enabled)
+            await InstallDxvk().ConfigureAwait(false);
 
         IsToolReady = true;
     }
 
-    private async Task DownloadTool(DirectoryInfo tempPath)
+    public async Task DownloadWine()
     {
-        using var client = new HttpClient();
-        var tempFilePath = Path.Combine(tempPath.FullName, $"{Guid.NewGuid()}");
+        await DownloadTool(wineDirectory, Settings.DownloadUrl).ConfigureAwait(false);
+    }
+
+    public async Task DownloadDxvk()
+    {
+        await DownloadTool(dxvkDirectory, DxvkSettings.DownloadUrl).ConfigureAwait(false);
+    }
+
+    private async Task InstallDxvk()
+    {
+        var dxvkPath = Path.Combine(dxvkDirectory.FullName, DxvkSettings.FolderName, "x64");
+        if (!Directory.Exists(dxvkPath))
+        {
+            Log.Information($"DXVK does not exist, downloading {DxvkSettings.DownloadUrl}");
+            await DownloadDxvk().ConfigureAwait(false);
+        }
+
+        var system32 = Path.Combine(Settings.Prefix.FullName, "drive_c", "windows", "system32");
+        var files = Directory.GetFiles(dxvkPath);
 
-        await File.WriteAllBytesAsync(tempFilePath, await client.GetByteArrayAsync(WINE_XIV_RELEASE_URL).ConfigureAwait(false)).ConfigureAwait(false);
+        foreach (string fileName in files)
+        {
+            File.Copy(fileName, Path.Combine(system32, Path.GetFileName(fileName)), true);
+        }
 
-        PlatformHelpers.Untar(tempFilePath, this.toolDirectory.FullName);
+        // 32-bit files for Directx9.
+        var dxvkPath32 = Path.Combine(dxvkDirectory.FullName, DxvkSettings.FolderName, "x32");
+        var syswow64 = Path.Combine(Settings.Prefix.FullName, "drive_c", "windows", "syswow64");
 
-        Log.Information("Compatibility tool successfully extracted to {Path}", this.toolDirectory.FullName);
+        if (Directory.Exists(dxvkPath32))
+        {
+            files = Directory.GetFiles(dxvkPath32);
 
-        File.Delete(tempFilePath);
+            foreach (string fileName in files)
+            {
+                File.Copy(fileName, Path.Combine(syswow64, Path.GetFileName(fileName)), true);
+            }
+        }   
+    }
+
+    private async Task DownloadTool(DirectoryInfo installDirectory, string downloadUrl)
+    {
+        using var client = new HttpClient();
+        var tempPath = Path.GetTempFileName();
+
+        File.WriteAllBytes(tempPath, await client.GetByteArrayAsync(downloadUrl));
+        PlatformHelpers.Untar(tempPath, installDirectory.FullName);
+
+        File.Delete(tempPath);
     }
 
     private void ResetPrefix()
@@ -113,21 +151,59 @@ public class CompatibilityTools
 
     public void EnsurePrefix()
     {
-        RunInPrefix("cmd /c dir %userprofile%/Documents > nul").WaitForExit();
+        if (Settings.IsProton)
+            RunInMinProton("run", "cmd /c dir %userprofile%/Documents > nul").WaitForExit();
+        else
+            RunInPrefix("cmd /c dir %userprofile%/Documents > nul").WaitForExit();
     }
 
+    // This function exists to speed up launch times when using proton with soldier runtime.
+    public Process RunInMinProton(string verb, string command)
+    {
+        var psi = new ProcessStartInfo(Settings.AltWinePath);
+        psi.RedirectStandardOutput = true;
+        psi.RedirectStandardError = true;
+        psi.UseShellExecute = false;
+        psi.Environment.Add("WINEPREFIX", Settings.Prefix.FullName);
+        psi.Environment.Add("STEAM_COMPAT_DATA_PATH", Settings.ProtonPrefix);
+        psi.Environment.Add("STEAM_COMPAT_CLIENT_INSTALL_PATH", Settings.SteamPath);
+        psi.Environment.Add("WINEDLLOVERRIDES", $"msquic=,mscoree=n,b;d3d9,d3d11,d3d10core,{(DxvkSettings.VKD3DEnabled && DxvkSettings.Enabled ? ",d3d12," : "")}dxgi={(DxvkSettings.Enabled ? "n,b" : "b")}");
+ 
+        psi.Arguments = verb + (string.IsNullOrWhiteSpace(command) ? "" : " " + command.Trim());
+       
+        var minProton = new Process();
+        minProton.StartInfo = psi;
+        minProton.Start();
+        Log.Verbose($"Running minimal proton in prefix: {psi.FileName} {psi.Arguments}");
+        return minProton;
+    }    
+
     public Process RunInPrefix(string command, string workingDirectory = "", IDictionary<string, string> environment = null, bool redirectOutput = false, bool writeLog = false, bool wineD3D = false)
     {
-        var psi = new ProcessStartInfo(Wine64Path);
-        psi.Arguments = command;
+        var psi = new ProcessStartInfo(Settings.WinePath);
+        var sb = new System.Text.StringBuilder();
+        if (Settings.IsProton)
+        {
+            if (!string.IsNullOrEmpty(Settings.Arguments))
+                sb.Append(Settings.Arguments + " ");
+            sb.Append("runinprefix ");
+        }
+        sb.Append(command);
+        psi.Arguments = sb.ToString();
 
-        Log.Verbose("Running in prefix: {FileName} {Arguments}", psi.FileName, command);
+        Log.Verbose("Running in prefix: {FileName} {Arguments}", psi.FileName, psi.Arguments);
         return RunInPrefix(psi, workingDirectory, environment, redirectOutput, writeLog, wineD3D);
     }
 
     public Process RunInPrefix(string[] args, string workingDirectory = "", IDictionary<string, string> environment = null, bool redirectOutput = false, bool writeLog = false, bool wineD3D = false)
     {
-        var psi = new ProcessStartInfo(Wine64Path);
+        var psi = new ProcessStartInfo(Settings.WinePath);
+        if (Settings.IsProton)
+        {
+            foreach (var param in Settings.Arguments.Split(null as char[], StringSplitOptions.RemoveEmptyEntries))
+                psi.ArgumentList.Add(param);
+            psi.ArgumentList.Add("runinprefix");
+        }
         foreach (var arg in args)
             psi.ArgumentList.Add(arg);
 
@@ -135,7 +211,7 @@ public class CompatibilityTools
         return RunInPrefix(psi, workingDirectory, environment, redirectOutput, writeLog, wineD3D);
     }
 
-    private void MergeDictionaries(StringDictionary a, IDictionary<string, string> b)
+    private void MergeDictionaries(IDictionary<string, string> a, IDictionary<string, string> b)
     {
         if (b is null)
             return;
@@ -143,12 +219,34 @@ public class CompatibilityTools
         foreach (var keyValuePair in b)
         {
             if (a.ContainsKey(keyValuePair.Key))
-                a[keyValuePair.Key] = keyValuePair.Value;
+            {
+                if (keyValuePair.Key == "LD_PRELOAD")
+                    a[keyValuePair.Key] = MergeLDPreload(a[keyValuePair.Key], keyValuePair.Value);
+                else
+                    a[keyValuePair.Key] = keyValuePair.Value;
+            }
             else
                 a.Add(keyValuePair.Key, keyValuePair.Value);
         }
     }
 
+    private string MergeLDPreload(string a, string b)
+    {
+        a ??= "";
+        b ??= "";
+        return (a.Trim(':') + ":" + b.Trim(':')).Trim(':');
+    }
+
+    public void AddEnvironmentVar(string key, string value)
+    {
+        extraEnvironmentVars.Add(key, value);
+    }
+
+    public void AddEnvironmentVars(IDictionary<string, string> env)
+    {
+        MergeDictionaries(extraEnvironmentVars, env);
+    }
+
     private Process RunInPrefix(ProcessStartInfo psi, string workingDirectory, IDictionary<string, string> environment, bool redirectOutput, bool writeLog, bool wineD3D)
     {
         psi.RedirectStandardOutput = redirectOutput;
@@ -156,48 +254,70 @@ public class CompatibilityTools
         psi.UseShellExecute = false;
         psi.WorkingDirectory = workingDirectory;
 
-        var wineEnviromentVariables = new Dictionary<string, string>();
-        wineEnviromentVariables.Add("WINEPREFIX", Settings.Prefix.FullName);
-        wineEnviromentVariables.Add("WINEDLLOVERRIDES", $"msquic=,mscoree=n,b;d3d9,d3d11,d3d10core,dxgi={(wineD3D ? "b" : "n")}");
+        wineD3D = !DxvkSettings.Enabled || wineD3D;
+
+        var wineEnvironmentVariables = new Dictionary<string, string>();
+        wineEnvironmentVariables.Add("WINEPREFIX", Settings.Prefix.FullName);
+        wineEnvironmentVariables.Add("WINEDLLOVERRIDES", $"msquic=,mscoree=n,b;d3d9,d3d11,d3d10core,{(DxvkSettings.VKD3DEnabled && wineD3D ? ",d3d12," : "")}dxgi={(wineD3D ? "b" : "n,b")}");
 
         if (!string.IsNullOrEmpty(Settings.DebugVars))
         {
-            wineEnviromentVariables.Add("WINEDEBUG", Settings.DebugVars);
+            wineEnvironmentVariables.Add("WINEDEBUG", Settings.DebugVars);
         }
 
-        wineEnviromentVariables.Add("XL_WINEONLINUX", "true");
-        string ldPreload = Environment.GetEnvironmentVariable("LD_PRELOAD") ?? "";
+        wineEnvironmentVariables.Add("XL_WINEONLINUX", "true");
 
-        string dxvkHud = hudType switch
-        {
-            Dxvk.DxvkHudType.None => "0",
-            Dxvk.DxvkHudType.Fps => "fps",
-            Dxvk.DxvkHudType.Full => "full",
-            _ => throw new ArgumentOutOfRangeException()
-        };
+        var ldpreload = MergeLDPreload(Environment.GetEnvironmentVariable("XL_PRELOAD"), Environment.GetEnvironmentVariable("LD_PRELOAD"));
+        if (this.gamemodeOn)
+            wineEnvironmentVariables.Add("LD_PRELOAD", MergeLDPreload("libgamemodeauto.so.0" , ldpreload));
 
-        if (this.gamemodeOn == true && !ldPreload.Contains("libgamemodeauto.so.0"))
+        if (!Settings.IsProton)
         {
-            ldPreload = ldPreload.Equals("") ? "libgamemodeauto.so.0" : ldPreload + ":libgamemodeauto.so.0";
+            if (Settings.EsyncOn) wineEnvironmentVariables.Add("WINEESYNC", "1");
+            if (Settings.FsyncOn) wineEnvironmentVariables.Add("WINEFSYNC", "1");
+        }
+        else
+        {
+            if (wineD3D)
+            {
+                DxvkSettings.Environment.Add("PROTON_USE_WINED3D", "1");
+            }
+            DxvkSettings.Environment.Remove("DXVK_CONFIG_FILE");
+            DxvkSettings.Environment.Remove("DXVK_STATE_CACHE_PATH");
+            wineEnvironmentVariables.Add("STEAM_COMPAT_DATA_PATH", Settings.ProtonPrefix);
+            wineEnvironmentVariables.Add("STEAM_COMPAT_CLIENT_INSTALL_PATH", Settings.SteamPath);
+            if (!Settings.FsyncOn)
+            {
+                if (!Settings.EsyncOn)
+                    wineEnvironmentVariables.Add("PROTON_NO_ESYNC", "1");
+                wineEnvironmentVariables.Add("PROTON_NO_FSYNC", "1");
+            }
+            if (!string.IsNullOrEmpty(Settings.RuntimePath))
+            {
+                var compatMounts = new System.Text.StringBuilder(System.Environment.GetEnvironmentVariable("STEAM_COMPAT_MOUNTS") ?? "");
+                compatMounts.Append($":{Settings.GameConfigPath}:");
+                if (!string.IsNullOrEmpty(Settings.RuntimePath))
+                {
+                    var runPath = System.Environment.GetEnvironmentVariable("XDG_RUNTIME_DIR");
+                    for (int i = 0; i < 10; i++)
+                        compatMounts.Append($"{runPath}/discord-ipc-{i}:{runPath}/app/com.discordapp.Discord/discord-ipc-{i}:{runPath}/snap.discord-cananry/discord-ipc-{i}:");
+                }
+                wineEnvironmentVariables.Add("STEAM_COMPAT_MOUNTS", compatMounts.ToString().Trim(':'));
+            }
         }
 
-        wineEnviromentVariables.Add("DXVK_HUD", dxvkHud);
-        wineEnviromentVariables.Add("DXVK_ASYNC", dxvkAsyncOn);
-        wineEnviromentVariables.Add("WINEESYNC", Settings.EsyncOn);
-        wineEnviromentVariables.Add("WINEFSYNC", Settings.FsyncOn);
-
-        wineEnviromentVariables.Add("LD_PRELOAD", ldPreload);
-
-        MergeDictionaries(psi.EnvironmentVariables, wineEnviromentVariables);
-        MergeDictionaries(psi.EnvironmentVariables, environment);
+        MergeDictionaries(psi.Environment, DxvkSettings.Environment);
+        MergeDictionaries(psi.Environment, wineEnvironmentVariables);
+        MergeDictionaries(psi.Environment, extraEnvironmentVars);       // Allow extraEnvironmentVars to override what we set here.
+        MergeDictionaries(psi.Environment, environment);
 
 #if FLATPAK_NOTRIGHTNOW
         psi.FileName = "flatpak-spawn";
 
         psi.ArgumentList.Insert(0, "--host");
-        psi.ArgumentList.Insert(1, Wine64Path);
+        psi.ArgumentList.Insert(1, Settings.WinePath);
 
-        foreach (KeyValuePair<string, string> envVar in wineEnviromentVariables)
+        foreach (KeyValuePair<string, string> envVar in wineEnvironmentVariables)
         {
             psi.ArgumentList.Insert(1, $"--env={envVar.Key}={envVar.Value}");
         }
@@ -257,18 +377,58 @@ public class CompatibilityTools
     {
         var wineDbg = RunInPrefix("winedbg --command \"info procmap\"", redirectOutput: true);
         var output = wineDbg.StandardOutput.ReadToEnd();
-        if (output.Contains("syntax error\n"))
-            return 0;
+        if (output.Contains("syntax error\n") || output.Contains("Exception c0000005")) // Proton8 wine changed the error message
+        {
+            var processName = GetProcessName(winePid);
+            return GetUnixProcessIdByName(processName);
+        }
         var matchingLines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries).Skip(1).Where(
             l => int.Parse(l.Substring(1, 8), System.Globalization.NumberStyles.HexNumber) == winePid);
         var unixPids = matchingLines.Select(l => int.Parse(l.Substring(10, 8), System.Globalization.NumberStyles.HexNumber)).ToArray();
         return unixPids.FirstOrDefault();
     }
 
+    private string GetProcessName(Int32 winePid)
+    {
+        var wineDbg = RunInPrefix("winedbg --command \"info proc\"", redirectOutput: true);
+        var output = wineDbg.StandardOutput.ReadToEnd();
+        var matchingLines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries).Skip(1).Where(
+            l => int.Parse(l.Substring(1, 8), System.Globalization.NumberStyles.HexNumber) == winePid);
+        var processNames = matchingLines.Select(l => l.Substring(20).Trim('\'')).ToArray();
+        return processNames.FirstOrDefault();
+    }
+
+    private Int32 GetUnixProcessIdByName(string executableName)
+    {
+        int closest = 0;
+        int early = 0;
+        var currentProcess = Process.GetCurrentProcess(); // Gets XIVLauncher.Core's process
+        bool nonunique = false;
+        foreach (var process in Process.GetProcessesByName(executableName))
+        {
+            if (process.Id < currentProcess.Id)
+            {
+                early = process.Id;
+                continue;  // Process was launched before XIVLauncher.Core
+            }
+            // Assume that the closest PID to XIVLauncher.Core's is the correct one. But log an error if more than one is found.
+            if ((closest - currentProcess.Id) > (process.Id - currentProcess.Id) || closest == 0)
+            {
+                if (closest != 0) nonunique = true;
+                closest = process.Id;
+            }
+            if (nonunique) Log.Error($"More than one {executableName} found! Selecting the most likely match with process id {closest}.");
+        }
+        // Deal with rare edge-case where pid rollover causes the ffxiv pid to be lower than XLCore's.
+        if (closest == 0 && early != 0) closest = early;
+        if (closest != 0) Log.Verbose($"Process for {executableName} found using fallback method: {closest}. XLCore pid: {currentProcess.Id}");
+        return closest;
+    }
+
     public string UnixToWinePath(string unixPath)
     {
-        var launchArguments = new string[] { "winepath", "--windows", unixPath };
-        var winePath = RunInPrefix(launchArguments, redirectOutput: true);
+        var launchArguments = $"winepath --windows \"{unixPath}\"";
+        var winePath = (Settings.IsProton) ? RunInMinProton("runinprefix", launchArguments) : RunInPrefix(launchArguments, redirectOutput: true);
         var output = winePath.StandardOutput.ReadToEnd();
         return output.Split('\n', StringSplitOptions.RemoveEmptyEntries).LastOrDefault();
     }
@@ -282,7 +442,7 @@ public class CompatibilityTools
 
     public void Kill()
     {
-        var psi = new ProcessStartInfo(WineServerPath)
+        var psi = new ProcessStartInfo(Settings.WineServerPath)
         {
             Arguments = "-k"
         };
diff --git a/src/XIVLauncher.Common.Unix/Compatibility/Dxvk.cs b/src/XIVLauncher.Common.Unix/Compatibility/Dxvk.cs
deleted file mode 100644
index 50fa98d9..00000000
--- a/src/XIVLauncher.Common.Unix/Compatibility/Dxvk.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-ï»¿using System.IO;
-using System.Net.Http;
-using System.Threading.Tasks;
-using Serilog;
-using XIVLauncher.Common.Util;
-
-namespace XIVLauncher.Common.Unix.Compatibility;
-
-public static class Dxvk
-{
-    private const string DXVK_DOWNLOAD = "https://github.com/Sporif/dxvk-async/releases/download/1.10.1/dxvk-async-1.10.1.tar.gz";
-    private const string DXVK_NAME = "dxvk-async-1.10.1";
-
-    public static async Task InstallDxvk(DirectoryInfo prefix, DirectoryInfo installDirectory)
-    {
-        var dxvkPath = Path.Combine(installDirectory.FullName, DXVK_NAME, "x64");
-
-        if (!Directory.Exists(dxvkPath))
-        {
-            Log.Information("DXVK does not exist, downloading");
-            await DownloadDxvk(installDirectory).ConfigureAwait(false);
-        }
-
-        var system32 = Path.Combine(prefix.FullName, "drive_c", "windows", "system32");
-        var files = Directory.GetFiles(dxvkPath);
-
-        foreach (string fileName in files)
-        {
-            File.Copy(fileName, Path.Combine(system32, Path.GetFileName(fileName)), true);
-        }
-    }
-
-    private static async Task DownloadDxvk(DirectoryInfo installDirectory)
-    {
-        using var client = new HttpClient();
-        var tempPath = Path.GetTempFileName();
-
-        File.WriteAllBytes(tempPath, await client.GetByteArrayAsync(DXVK_DOWNLOAD));
-        PlatformHelpers.Untar(tempPath, installDirectory.FullName);
-
-        File.Delete(tempPath);
-    }
-
-    public enum DxvkHudType
-    {
-        [SettingsDescription("None", "Show nothing")]
-        None,
-
-        [SettingsDescription("FPS", "Only show FPS")]
-        Fps,
-
-        [SettingsDescription("Full", "Show everything")]
-        Full,
-    }
-}
\ No newline at end of file
diff --git a/src/XIVLauncher.Common.Unix/Compatibility/DxvkSettings.cs b/src/XIVLauncher.Common.Unix/Compatibility/DxvkSettings.cs
new file mode 100644
index 00000000..482d7b68
--- /dev/null
+++ b/src/XIVLauncher.Common.Unix/Compatibility/DxvkSettings.cs
@@ -0,0 +1,90 @@
+using System.IO;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+using System.Linq;
+using Serilog;
+
+namespace XIVLauncher.Common.Unix.Compatibility;
+
+public class DxvkSettings
+{
+    public bool Enabled { get; }
+
+    public bool VKD3DEnabled { get; }
+
+    public string FolderName { get; }
+
+    public string DownloadUrl { get; }
+
+    public Dictionary<string, string> Environment { get; }
+
+    public DxvkSettings(string folder, string url, string storageFolder, bool async, int maxFrameRate, bool dxvkHudEnabled, string dxvkHudString, bool mangoHudEnabled = false, bool mangoHudCustomIsFile = false, string customMangoHud = "", bool enabled = true, bool vkd3d = false)
+    {
+        FolderName = folder;
+        DownloadUrl = url;
+        Enabled = enabled;
+        VKD3DEnabled = vkd3d;
+
+        var dxvkConfigPath = new DirectoryInfo(Path.Combine(storageFolder, "compatibilitytool", "dxvk"));
+        Environment = new Dictionary<string, string>
+        {
+            { "DXVK_LOG_PATH", Path.Combine(storageFolder, "logs") },
+            { "DXVK_CONFIG_FILE", Path.Combine(dxvkConfigPath.FullName, "dxvk.conf") },
+        };
+        
+        if (maxFrameRate != 0)
+            Environment.Add("DXVK_FRAME_RATE", (maxFrameRate).ToString());
+        
+        if (async)
+            Environment.Add("DXVK_ASYNC", "1");
+        
+        var dxvkCachePath = new DirectoryInfo(Path.Combine(dxvkConfigPath.FullName, "cache"));
+        if (!dxvkCachePath.Exists) dxvkCachePath.Create();
+        Environment.Add("DXVK_STATE_CACHE_PATH", Path.Combine(dxvkCachePath.FullName, folder));
+
+        if (dxvkHudEnabled)
+            Environment.Add("DXVK_HUD", DxvkHudStringIsValid(dxvkHudString) ? dxvkHudString : "1");
+
+        if (mangoHudEnabled && MangoHudIsInstalled())
+        {
+            Environment.Add("MANGOHUD", "1");
+            if (mangoHudCustomIsFile)
+            {
+                if (File.Exists(customMangoHud))
+                    Environment.Add("MANGOHUD_CONFIGFILE", customMangoHud);
+                else
+                    Environment.Add("MANGOHUD_CONFIG", "");
+            }
+            else
+            {
+                Environment.Add("MANGOHUD_CONFIG", customMangoHud);
+            }
+        }
+    }
+
+    public static bool DxvkHudStringIsValid(string customHud)
+    {
+        var ALLOWED_CHARS = "^[0-9a-zA-Z,=.]+$";
+        var ALLOWED_WORDS = "^(?:devinfo|fps|frametimes|submissions|drawcalls|pipelines|descriptors|memory|gpuload|version|api|cs|compiler|samplers|scale=(?:[0-9])*(?:.(?:[0-9])+)?)$";
+
+        if (string.IsNullOrWhiteSpace(customHud)) return false;
+        if (customHud == "full") return true;
+        if (customHud == "1") return true;
+        if (!Regex.IsMatch(customHud, ALLOWED_CHARS)) return false;
+
+        string[] hudvars = customHud.Split(",");
+
+        return hudvars.All(hudvar => Regex.IsMatch(hudvar, ALLOWED_WORDS));        
+    }
+
+    public static bool MangoHudIsInstalled()
+    {
+        var usrLib = Path.Combine("/", "usr", "lib", "mangohud", "libMangoHud.so"); // fedora uses this
+        var usrLib64 = Path.Combine("/", "usr", "lib64", "mangohud", "libMangoHud.so"); // arch and openSUSE use this
+        var flatpak = Path.Combine("/", "usr", "lib", "extensions", "vulkan", "MangoHud", "lib", "x86_64-linux-gnu", "libMangoHud.so");
+        var debuntu = Path.Combine("/", "usr", "lib", "x86_64-linux-gnu", "mangohud", "libMangoHud.so");
+        if (File.Exists(usrLib64) || File.Exists(usrLib) || File.Exists(flatpak) || File.Exists(debuntu))
+            return true;
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/src/XIVLauncher.Common.Unix/Compatibility/ProtonSettings.cs b/src/XIVLauncher.Common.Unix/Compatibility/ProtonSettings.cs
new file mode 100644
index 00000000..0c8929ea
--- /dev/null
+++ b/src/XIVLauncher.Common.Unix/Compatibility/ProtonSettings.cs
@@ -0,0 +1,30 @@
+using System.IO;
+
+namespace XIVLauncher.Common.Unix.Compatibility;
+
+public class ProtonSettings
+{
+    public string SteamPath { get; private set; }
+
+    public string ProtonPath { get; private set; }
+
+    public string RuntimePath { get; private set; }
+
+    public DirectoryInfo Prefix { get; private set; }
+
+    public DirectoryInfo GamePath { get; private set; }
+
+    public DirectoryInfo GameConfigPath { get; private set; }
+
+    public ProtonSettings(string? steamPath, string protonPath, string runtimePath, DirectoryInfo prefix, DirectoryInfo? gamePath, DirectoryInfo? gameConfig)
+    {
+        // none of these should ever actually be null, but this stops the editor and compiler from complaining.
+        var home = System.Environment.GetEnvironmentVariable("HOME") ?? "";
+        SteamPath = steamPath ?? Path.Combine(home, ".local", "share", "Steam");
+        ProtonPath = protonPath;
+        RuntimePath = runtimePath;
+        Prefix = prefix;
+        GamePath = gamePath ?? new DirectoryInfo(Path.Combine(home, ".xlcore", "ffxiv"));
+        GameConfigPath = gameConfig ?? new DirectoryInfo(Path.Combine(home, ".xlcore", "ffxivConfig"));
+    }
+}
\ No newline at end of file
diff --git a/src/XIVLauncher.Common.Unix/Compatibility/WineSettings.cs b/src/XIVLauncher.Common.Unix/Compatibility/WineSettings.cs
index 9b122f7a..3e49447d 100644
--- a/src/XIVLauncher.Common.Unix/Compatibility/WineSettings.cs
+++ b/src/XIVLauncher.Common.Unix/Compatibility/WineSettings.cs
@@ -1,37 +1,76 @@
 ï»¿using System.IO;
+using System.Collections.Generic;
 
 namespace XIVLauncher.Common.Unix.Compatibility;
 
-public enum WineStartupType
+public class WineSettings
 {
-    [SettingsDescription("Managed by XIVLauncher", "The game installation and wine setup is managed by XIVLauncher - you can leave it up to us.")]
-    Managed,
+    public bool IsManaged { get; private set; }
 
-    [SettingsDescription("Custom", "Point XIVLauncher to a custom location containing wine binaries to run the game with.")]
-    Custom,
-}
+    public bool IsProton { get; private set; }
 
-public class WineSettings
-{
-    public WineStartupType StartupType { get; private set; }
-    public string CustomBinPath { get; private set; }
+    public string WineServerPath { get; private set; }
+
+    public string WinePath { get; private set; }
+
+    private string BinPath;
+
+    public string AltWinePath { get; private set; }
+
+    public string Arguments { get; private set; }
+
+    public string RuntimePath { get; private set; }
+
+    public string FolderName { get; private set; }
 
-    public string EsyncOn { get; private set; }
-    public string FsyncOn { get; private set; }
+    public string DownloadUrl { get; private set; }
+
+    public bool EsyncOn { get; private set; }
+
+    public bool FsyncOn { get; private set; }
 
     public string DebugVars { get; private set; }
+
     public FileInfo LogFile { get; private set; }
 
     public DirectoryInfo Prefix { get; private set; }
 
-    public WineSettings(WineStartupType? startupType, string customBinPath, string debugVars, FileInfo logFile, DirectoryInfo prefix, bool? esyncOn, bool? fsyncOn)
+    public string GamePath { get; private set; }
+
+    public string GameConfigPath { get; private set; }
+
+    public string ProtonPrefix { get; private set; }
+    public string SteamPath { get; private set; }
+
+    public WineSettings(bool isManaged, string customBinPath, string managedFolder, string managedUrl, DirectoryInfo storageFolder, string debugVars, FileInfo logFile, DirectoryInfo prefix, bool? esyncOn, bool? fsyncOn, ProtonSettings? protonInfo)
     {
-        this.StartupType = startupType ?? WineStartupType.Custom;
-        this.CustomBinPath = customBinPath;
-        this.EsyncOn = (esyncOn ?? false) ? "1" : "0";
-        this.FsyncOn = (fsyncOn ?? false) ? "1" : "0";
-        this.DebugVars = debugVars;
-        this.LogFile = logFile;
-        this.Prefix = prefix;
+        // storageFolder is the path to .xlcore folder. managedFolder is the foldername inside the tarball that will be downloaded from managedUrl.
+        IsManaged = isManaged;
+        IsProton = protonInfo is not null;
+        FolderName = managedFolder;
+        DownloadUrl = managedUrl;
+        BinPath = IsProton ? protonInfo.ProtonPath : (isManaged ? Path.Combine(storageFolder.FullName, "compatibilitytool", "wine", managedFolder, "bin") : customBinPath);
+        WineServerPath = IsProton ? Path.Combine(BinPath, "files", "bin", "wineserver") : Path.Combine(BinPath, "wineserver");
+
+        EsyncOn = esyncOn ?? false;
+        FsyncOn = fsyncOn ?? false;
+        DebugVars = debugVars;
+        LogFile = logFile;
+        Prefix = IsProton ? new DirectoryInfo(Path.Combine(protonInfo.Prefix.FullName, "pfx")) : prefix;
+        ProtonPrefix = IsProton ? protonInfo.Prefix.FullName : "";
+
+        SteamPath = IsProton ? protonInfo.SteamPath : "";
+        WinePath = IsProton ? Path.Combine(BinPath, "proton") : File.Exists(Path.Combine(BinPath, "wine64")) ? Path.Combine(BinPath, "wine64") : Path.Combine(BinPath, "wine");
+        AltWinePath = WinePath;
+        RuntimePath = IsProton ? protonInfo.RuntimePath : "";
+        Arguments = "";
+        if (!string.IsNullOrEmpty(RuntimePath))
+        {
+            var binary = Path.Combine(RuntimePath, "_v2-entry-point");
+            Arguments = $"--verb=waitforexitandrun -- \"{Path.Combine(BinPath, "proton")}\"";
+            WinePath = binary;
+        }
+        GamePath = IsProton ? protonInfo.GamePath.FullName : "";
+        GameConfigPath = IsProton ? protonInfo.GameConfigPath.FullName : "";
     }
 }
\ No newline at end of file
diff --git a/src/XIVLauncher.Common.Unix/UnixDalamudRunner.cs b/src/XIVLauncher.Common.Unix/UnixDalamudRunner.cs
index ef1b8545..b2fde02c 100644
--- a/src/XIVLauncher.Common.Unix/UnixDalamudRunner.cs
+++ b/src/XIVLauncher.Common.Unix/UnixDalamudRunner.cs
@@ -74,12 +74,28 @@ public class UnixDalamudRunner : IDalamudRunner
         launchArguments.Add(gameArgs);
 
         var dalamudProcess = compatibility.RunInPrefix(string.Join(" ", launchArguments), environment: environment, redirectOutput: true, writeLog: true);
-        var output = dalamudProcess.StandardOutput.ReadLine();
 
-        if (output == null)
-            throw new DalamudRunnerException("An internal Dalamud error has occured");
+        DalamudConsoleOutput dalamudConsoleOutput = null;
+        int invalidJsonCount = 0;
 
-        Console.WriteLine(output);
+        // Keep checking for valid json output, but only 5 times. If it's still erroring out at that point, give up.
+        while (dalamudConsoleOutput == null && invalidJsonCount < 5)
+        {
+            var output = dalamudProcess.StandardOutput.ReadLine();
+            if (output == null)
+                throw new DalamudRunnerException("An internal Dalamud error has occured");
+            Console.WriteLine(output);
+
+            try
+            {
+                dalamudConsoleOutput = JsonConvert.DeserializeObject<DalamudConsoleOutput>(output);
+            }
+            catch (Exception ex)
+            {
+                Log.Warning(ex, $"Couldn't parse Dalamud output: {output}");
+            }
+            invalidJsonCount++;
+        }
 
         new Thread(() =>
         {
@@ -89,17 +105,15 @@ public class UnixDalamudRunner : IDalamudRunner
                 if (output != null)
                     Console.WriteLine(output);
             }
-
         }).Start();
 
         try
         {
-            var dalamudConsoleOutput = JsonConvert.DeserializeObject<DalamudConsoleOutput>(output);
             var unixPid = compatibility.GetUnixProcessId(dalamudConsoleOutput.Pid);
 
             if (unixPid == 0)
             {
-                Log.Error("Could not retrive Unix process ID, this feature currently requires a patched wine version");
+                Log.Error("Could not retrieve Unix process ID");
                 return null;
             }
 
@@ -107,9 +121,9 @@ public class UnixDalamudRunner : IDalamudRunner
             Log.Verbose($"Got game process handle {gameProcess.Handle} with Unix pid {gameProcess.Id} and Wine pid {dalamudConsoleOutput.Pid}");
             return gameProcess;
         }
-        catch (JsonReaderException ex)
+        catch (Exception ex)
         {
-            Log.Error(ex, $"Couldn't parse Dalamud output: {output}");
+            Log.Error(ex, $"Could not retrieve game Process information");
             return null;
         }
     }
diff --git a/src/XIVLauncher.Common/Dalamud/AssetManager.cs b/src/XIVLauncher.Common/Dalamud/AssetManager.cs
index ea64a579..0f675d76 100644
--- a/src/XIVLauncher.Common/Dalamud/AssetManager.cs
+++ b/src/XIVLauncher.Common/Dalamud/AssetManager.cs
@@ -113,7 +113,7 @@ namespace XIVLauncher.Common.Dalamud
 
                 var packageUrl = info.PackageUrl;
 
-                var tempPath = Path.GetTempFileName();
+                var tempPath = PlatformHelpers.GetTempFileName();
 
                 if (File.Exists(tempPath))
                     File.Delete(tempPath);
diff --git a/src/XIVLauncher.Common/Game/Headlines.cs b/src/XIVLauncher.Common/Game/Headlines.cs
index 4d664547..79a5ff79 100644
--- a/src/XIVLauncher.Common/Game/Headlines.cs
+++ b/src/XIVLauncher.Common/Game/Headlines.cs
@@ -1,4 +1,5 @@
 ï»¿using System;
+using System.Collections.Generic;
 using System.Globalization;
 using System.Text;
 using System.Threading.Tasks;
@@ -18,9 +19,6 @@ namespace XIVLauncher.Common.Game
 
         [JsonProperty("pinned")]
         public News[] Pinned { get; set; }
-
-        [JsonProperty("banner")]
-        public Banner[] Banner { get; set; }
     }
 
     public class Banner
@@ -30,6 +28,18 @@ namespace XIVLauncher.Common.Game
 
         [JsonProperty("link")]
         public Uri Link { get; set; }
+
+        [JsonProperty("order_priority")]
+        public int? OrderPriority { get; set; }
+
+        [JsonProperty("fix_order")]
+        public int? FixOrder { get; set; }
+    }
+
+    public class BannerRoot
+    {
+        [JsonProperty("banner")]
+        public List<Banner> Banner { get; set; }
     }
 
     public class News
@@ -52,7 +62,7 @@ namespace XIVLauncher.Common.Game
 
     public partial class Headlines
     {
-        public static async Task<Headlines> Get(Launcher game, ClientLanguage language, bool forceNa = false)
+        public static async Task<Headlines> GetNews(Launcher game, ClientLanguage language, bool forceNa = false)
         {
             var unixTimestamp = ApiHelpers.GetUnixMillis();
             var langCode = language.GetLangCode(forceNa);
@@ -62,6 +72,38 @@ namespace XIVLauncher.Common.Game
 
             return JsonConvert.DeserializeObject<Headlines>(json, Converter.SETTINGS);
         }
+
+        public static async Task<IReadOnlyList<Banner>> GetBanners(Launcher game, ClientLanguage language, bool forceNa = false)
+        {
+            var unixTimestamp = ApiHelpers.GetUnixMillis();
+            var langCode = language.GetLangCode(forceNa);
+            var url = $"https://frontier.ffxiv.com/v2/topics/{langCode}/banner.json?lang={langCode}&media=pcapp&_={unixTimestamp}";
+
+            var json = Encoding.UTF8.GetString(await game.DownloadAsLauncher(url, language, "application/json, text/plain, */*").ConfigureAwait(false));
+
+            return JsonConvert.DeserializeObject<BannerRoot>(json, Converter.SETTINGS).Banner;
+        }
+
+        public static async Task<IReadOnlyCollection<Banner>> GetMessage(Launcher game, ClientLanguage language, bool forceNa = false)
+        {
+            var unixTimestamp = ApiHelpers.GetUnixMillis();
+            var langCode = language.GetLangCode(forceNa);
+            var url = $"https://frontier.ffxiv.com/v2/notice/{langCode}/message.json?_={unixTimestamp}";
+
+            var json = Encoding.UTF8.GetString(await game.DownloadAsLauncher(url, language, "application/json, text/plain, */*").ConfigureAwait(false));
+
+            return JsonConvert.DeserializeObject<BannerRoot>(json, Converter.SETTINGS).Banner;
+        }
+
+        public static async Task<IReadOnlyCollection<Banner>> GetWorlds(Launcher game, ClientLanguage language)
+        {
+            var unixTimestamp = ApiHelpers.GetUnixMillis();
+            var url = $"https://frontier.ffxiv.com/v2/world/status.json?_={unixTimestamp}";
+
+            var json = Encoding.UTF8.GetString(await game.DownloadAsLauncher(url, language, "application/json, text/plain, */*").ConfigureAwait(false));
+
+            return JsonConvert.DeserializeObject<BannerRoot>(json, Converter.SETTINGS).Banner;
+        }
     }
 
     internal static class Converter
diff --git a/src/XIVLauncher.Common/Game/Launcher.cs b/src/XIVLauncher.Common/Game/Launcher.cs
index f9b28d13..97d61d64 100644
--- a/src/XIVLauncher.Common/Game/Launcher.cs
+++ b/src/XIVLauncher.Common/Game/Launcher.cs
@@ -1,5 +1,3 @@
-
-
 #nullable enable
 
 using System;
@@ -38,15 +36,13 @@ public class Launcher
     private readonly HttpClient client;
     private readonly string frontierUrlTemplate;
 
-    private const string FALLBACK_FRONTIER_URL_TEMPLATE = "https://launcher.finalfantasyxiv.com/v620/index.html?rc_lang={0}&time={1}";
-
-    public Launcher(ISteam? steam, IUniqueIdCache uniqueIdCache, ISettings settings, string? frontierUrl =  null)
+    public Launcher(ISteam? steam, IUniqueIdCache uniqueIdCache, ISettings settings, string frontierUrl)
     {
         this.steam = steam;
         this.uniqueIdCache = uniqueIdCache;
         this.settings = settings;
-        this.frontierUrlTemplate =
-            string.IsNullOrWhiteSpace(frontierUrl) ? FALLBACK_FRONTIER_URL_TEMPLATE : frontierUrl;
+
+        this.frontierUrlTemplate = frontierUrl ?? throw new Exception("Frontier URL template is null, this is now required");
 
         ServicePointManager.Expect100Continue = false;
 
@@ -71,7 +67,7 @@ public class Launcher
         this.client = new HttpClient(handler);
     }
 
-    public Launcher(byte[] steamTicket, IUniqueIdCache uniqueIdCache, ISettings settings, string? frontierUrl = null)
+    public Launcher(byte[] steamTicket, IUniqueIdCache uniqueIdCache, ISettings settings, string frontierUrl)
         : this(steam: null, uniqueIdCache, settings, frontierUrl)
     {
         this.steamTicket = steamTicket;
@@ -625,7 +621,7 @@ public class Launcher
         }
     }
 
-    public async Task<bool> GetLoginStatus()
+    public async Task<GateStatus> GetLoginStatus()
     {
         try
         {
@@ -633,11 +629,11 @@ public class Launcher
                 await DownloadAsLauncher(
                     $"https://frontier.ffxiv.com/worldStatus/login_status.json?_={ApiHelpers.GetUnixMillis()}", ClientLanguage.English).ConfigureAwait(true));
 
-            return Convert.ToBoolean(int.Parse(reply[10].ToString()));
+            return JsonConvert.DeserializeObject<GateStatus>(reply);
         }
         catch (Exception exc)
         {
-            throw new Exception("Could not get gate status", exc);
+            throw new Exception("Could not get login status", exc);
         }
     }
 
@@ -675,6 +671,7 @@ public class Launcher
         request.Headers.AddWithoutValidation("Origin", "https://launcher.finalfantasyxiv.com");
 
         request.Headers.AddWithoutValidation("Referer", GenerateFrontierReferer(language));
+        request.Headers.AddWithoutValidation("Connection", "Keep-Alive");
 
         var resp = await this.client.SendAsync(request);
         return await resp.Content.ReadAsByteArrayAsync();
diff --git a/src/XIVLauncher.Common/Patching/IndexedZiPatch/IndexedZiPatchIndexLocalInstaller.cs b/src/XIVLauncher.Common/Patching/IndexedZiPatch/IndexedZiPatchIndexLocalInstaller.cs
index 81e680af..2638e3f0 100644
--- a/src/XIVLauncher.Common/Patching/IndexedZiPatch/IndexedZiPatchIndexLocalInstaller.cs
+++ b/src/XIVLauncher.Common/Patching/IndexedZiPatch/IndexedZiPatchIndexLocalInstaller.cs
@@ -1,5 +1,4 @@
-ï»¿using Serilog;
-using System;
+ï»¿using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
@@ -152,4 +151,4 @@ namespace XIVLauncher.Common.Patching.IndexedZiPatch
             return Task.CompletedTask;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/XIVLauncher.Common/Patching/Util/FullDeflateStreamReader.cs b/src/XIVLauncher.Common/Patching/Util/FullDeflateStreamReader.cs
index 392994bc..61edc026 100644
--- a/src/XIVLauncher.Common/Patching/Util/FullDeflateStreamReader.cs
+++ b/src/XIVLauncher.Common/Patching/Util/FullDeflateStreamReader.cs
@@ -1,6 +1,4 @@
-ï»¿using System;
-using System.IO;
-using System.IO.Compression;
+ï»¿using System.IO.Compression;
 // ReSharper disable InconsistentNaming
 
 namespace XIVLauncher.Common.Patching.Util
diff --git a/src/XIVLauncher.Common/Patching/ZiPatch/Util/SqexFileStream.cs b/src/XIVLauncher.Common/Patching/ZiPatch/Util/SqexFileStream.cs
index 3661c6ff..5c0b9560 100644
--- a/src/XIVLauncher.Common/Patching/ZiPatch/Util/SqexFileStream.cs
+++ b/src/XIVLauncher.Common/Patching/ZiPatch/Util/SqexFileStream.cs
@@ -1,5 +1,4 @@
-ï»¿using System;
-using System.IO;
+ï»¿using System.IO;
 using System.Threading;
 
 namespace XIVLauncher.Common.Patching.ZiPatch.Util
diff --git a/src/XIVLauncher.Common/Util/PlatformHelpers.cs b/src/XIVLauncher.Common/Util/PlatformHelpers.cs
index d135b0b0..794f276c 100644
--- a/src/XIVLauncher.Common/Util/PlatformHelpers.cs
+++ b/src/XIVLauncher.Common/Util/PlatformHelpers.cs
@@ -31,7 +31,7 @@ public static class PlatformHelpers
     public static string GetTempFileName()
     {
         // https://stackoverflow.com/a/50413126
-        return Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
+        return Path.Combine(Path.GetTempPath(), "xivlauncher_" + Guid.NewGuid());
     }
 
     public static void DeleteAndRecreateDirectory(DirectoryInfo dir)
diff --git a/src/XIVLauncher/App.xaml.cs b/src/XIVLauncher/App.xaml.cs
index 01bb776e..d0ec9abd 100644
--- a/src/XIVLauncher/App.xaml.cs
+++ b/src/XIVLauncher/App.xaml.cs
@@ -16,7 +16,6 @@ using Serilog.Events;
 using XIVLauncher.Common;
 using XIVLauncher.Common.Dalamud;
 using XIVLauncher.Common.Game;
-using XIVLauncher.Common.PlatformAbstractions;
 using XIVLauncher.Common.Support;
 using XIVLauncher.Common.Util;
 using XIVLauncher.Common.Windows;
diff --git a/src/XIVLauncher/Resources/CHANGELOG.txt b/src/XIVLauncher/Resources/CHANGELOG.txt
index 591bd4db..0ee29365 100644
--- a/src/XIVLauncher/Resources/CHANGELOG.txt
+++ b/src/XIVLauncher/Resources/CHANGELOG.txt
@@ -1,8 +1,2 @@
-ï»¿* Fixes an issue wherein the game repair feature may not have functioned correctly
-* Fixes an issue wherein required data files for Dalamud may not have been downloaded correctly
-* Adds a separate button to the login menu, which will open advanced login options, in addition to right-clicking
-* Updated the localization files
-    => Thanks to our dedicated localization team!
-    
-Hotfix:
-* Fixes an issue wherein a window showing debug information may have been shown during patching
\ No newline at end of file
+ï»¿* Fixes an issue wherein required data files for Dalamud may not have been downloaded correctly under certain conditions
+* Fixes an issue wherein the banners shown on the main page were outdated
diff --git a/src/XIVLauncher/Windows/AdvancedSettingsWindow.xaml.cs b/src/XIVLauncher/Windows/AdvancedSettingsWindow.xaml.cs
index c16daf66..ed274fd2 100644
--- a/src/XIVLauncher/Windows/AdvancedSettingsWindow.xaml.cs
+++ b/src/XIVLauncher/Windows/AdvancedSettingsWindow.xaml.cs
@@ -1,5 +1,4 @@
-ï»¿using System;
-using System.Windows;
+ï»¿using System.Windows;
 using XIVLauncher.Windows.ViewModel;
 
 namespace XIVLauncher.Windows
diff --git a/src/XIVLauncher/Windows/MainWindow.xaml b/src/XIVLauncher/Windows/MainWindow.xaml
index c5f11a33..1d0e4289 100644
--- a/src/XIVLauncher/Windows/MainWindow.xaml
+++ b/src/XIVLauncher/Windows/MainWindow.xaml
@@ -174,7 +174,7 @@
                                     <StackPanel Orientation="Vertical"
                                                 HorizontalAlignment="Stretch" VerticalAlignment="Stretch">
                                         <materialDesign:PackIcon Kind="Earth" Height="Auto"
-                                                                 Width="Auto" x:Name="WorldStatusPackIcon" />
+                                                                 Width="Auto" Foreground="{Binding WorldStatusIconColor}"/>
                                     </StackPanel>
                                 </Button>
 
diff --git a/src/XIVLauncher/Windows/MainWindow.xaml.cs b/src/XIVLauncher/Windows/MainWindow.xaml.cs
index 1c5c04d1..89420daf 100644
--- a/src/XIVLauncher/Windows/MainWindow.xaml.cs
+++ b/src/XIVLauncher/Windows/MainWindow.xaml.cs
@@ -34,6 +34,7 @@ namespace XIVLauncher.Windows
     {
         private Timer _bannerChangeTimer;
         private Headlines _headlines;
+        private IReadOnlyList<Banner> _banners;
         private BitmapImage[] _bannerBitmaps;
         private int _currentBannerIndex;
         private bool _everShown = false;
@@ -121,14 +122,20 @@ namespace XIVLauncher.Windows
             {
                 _bannerChangeTimer?.Stop();
 
-                _headlines = await Headlines.Get(_launcher, App.Settings.Language.GetValueOrDefault(ClientLanguage.English), App.Settings.ForceNorthAmerica.GetValueOrDefault(false)).ConfigureAwait(false);
+                await Headlines.GetWorlds(_launcher, App.Settings.Language.GetValueOrDefault(ClientLanguage.English));
+                _banners = await Headlines.GetBanners(_launcher, App.Settings.Language.GetValueOrDefault(ClientLanguage.English), App.Settings.ForceNorthAmerica.GetValueOrDefault(false))
+                                          .ConfigureAwait(false);
+                await Headlines.GetMessage(_launcher, App.Settings.Language.GetValueOrDefault(ClientLanguage.English), App.Settings.ForceNorthAmerica.GetValueOrDefault(false))
+                               .ConfigureAwait(false);
+                _headlines = await Headlines.GetNews(_launcher, App.Settings.Language.GetValueOrDefault(ClientLanguage.English), App.Settings.ForceNorthAmerica.GetValueOrDefault(false))
+                                            .ConfigureAwait(false);
 
-                _bannerBitmaps = new BitmapImage[_headlines.Banner.Length];
+                _bannerBitmaps = new BitmapImage[_banners.Count];
                 _bannerDotList = new();
 
-                for (var i = 0; i < _headlines.Banner.Length; i++)
+                for (var i = 0; i < _banners.Count; i++)
                 {
-                    var imageBytes = await _launcher.DownloadAsLauncher(_headlines.Banner[i].LsbBanner.ToString(), App.Settings.Language.GetValueOrDefault(ClientLanguage.English));
+                    var imageBytes = await _launcher.DownloadAsLauncher(_banners[i].LsbBanner.ToString(), App.Settings.Language.GetValueOrDefault(ClientLanguage.English));
 
                     using var stream = new MemoryStream(imageBytes);
 
@@ -157,7 +164,7 @@ namespace XIVLauncher.Windows
                 {
                     _bannerDotList.ToList().ForEach(x => x.Active = false);
 
-                    if (_currentBannerIndex + 1 > _headlines.Banner.Length - 1)
+                    if (_currentBannerIndex + 1 > _banners.Count - 1)
                         _currentBannerIndex = 0;
                     else
                         _currentBannerIndex++;
@@ -176,8 +183,9 @@ namespace XIVLauncher.Windows
 
                 Dispatcher.BeginInvoke(new Action(() => { NewsListView.ItemsSource = _headlines.News; }));
             }
-            catch (Exception)
+            catch (Exception ex)
             {
+                Log.Error(ex, "Could not get news");
                 Dispatcher.BeginInvoke(new Action(() =>
                 {
                     NewsListView.ItemsSource = new List<News> {new News {Title = Loc.Localize("NewsDlFailed", "Could not download news data."), Tag = "DlError"}};
@@ -272,23 +280,6 @@ namespace XIVLauncher.Windows
 
             this.SetDefaults();
 
-            var worldStatusBrushOk = WorldStatusPackIcon.Foreground;
-            // grey out world status icon while deferred check is running
-            WorldStatusPackIcon.Foreground = new SolidColorBrush(Color.FromRgb(38, 38, 38));
-
-            _launcher.GetGateStatus(App.Settings.Language.GetValueOrDefault(ClientLanguage.English)).ContinueWith((resultTask) =>
-            {
-                try
-                {
-                    var brushToSet = resultTask.Result.Status ? worldStatusBrushOk : null;
-                    Dispatcher.InvokeAsync(() =>  WorldStatusPackIcon.Foreground = brushToSet ?? new SolidColorBrush(Color.FromRgb(242, 24, 24)));
-                }
-                catch
-                {
-                    // ignored
-                }
-            });
-
             _accountManager = new AccountManager(App.Settings);
 
             var savedAccount = _accountManager.CurrentAccount;
@@ -359,7 +350,7 @@ namespace XIVLauncher.Windows
             if (e.ChangedButton != MouseButton.Left)
                 return;
 
-            if (_headlines != null) Process.Start(_headlines.Banner[_currentBannerIndex].Link.ToString());
+            if (_headlines != null) Process.Start(_banners[_currentBannerIndex].Link.ToString());
         }
 
         private void NewsListView_OnMouseUp(object sender, MouseButtonEventArgs e)
diff --git a/src/XIVLauncher/Windows/PatchDownloadDialog.xaml.cs b/src/XIVLauncher/Windows/PatchDownloadDialog.xaml.cs
index 76fcb376..7292afdb 100644
--- a/src/XIVLauncher/Windows/PatchDownloadDialog.xaml.cs
+++ b/src/XIVLauncher/Windows/PatchDownloadDialog.xaml.cs
@@ -5,7 +5,6 @@ using System.Timers;
 using System.Windows;
 using System.Windows.Input;
 using XIVLauncher.Common.Game.Patch;
-using XIVLauncher.Common.Game.Patch.Acquisition;
 using XIVLauncher.Common.Util;
 using XIVLauncher.Windows.ViewModel;
 using Brushes = System.Windows.Media.Brushes;
diff --git a/src/XIVLauncher/Windows/SettingsControl.xaml.cs b/src/XIVLauncher/Windows/SettingsControl.xaml.cs
index 82c7b053..bfef825d 100644
--- a/src/XIVLauncher/Windows/SettingsControl.xaml.cs
+++ b/src/XIVLauncher/Windows/SettingsControl.xaml.cs
@@ -11,7 +11,6 @@ using CheapLoc;
 using MaterialDesignThemes.Wpf.Transitions;
 using Serilog;
 using XIVLauncher.Common.Game;
-using Newtonsoft.Json.Linq;
 using XIVLauncher.Common;
 using XIVLauncher.Common.Addon;
 using XIVLauncher.Common.Addon.Implementations;
diff --git a/src/XIVLauncher/Windows/ViewModel/MainWindowViewModel.cs b/src/XIVLauncher/Windows/ViewModel/MainWindowViewModel.cs
index 523eef88..e347b7e1 100644
--- a/src/XIVLauncher/Windows/ViewModel/MainWindowViewModel.cs
+++ b/src/XIVLauncher/Windows/ViewModel/MainWindowViewModel.cs
@@ -10,6 +10,7 @@ using System.Threading;
 using System.Threading.Tasks;
 using System.Windows;
 using System.Windows.Input;
+using System.Windows.Media;
 using System.Windows.Threading;
 using CheapLoc;
 using Serilog;
@@ -36,6 +37,9 @@ namespace XIVLauncher.Windows.ViewModel
     {
         private readonly Window _window;
 
+        private readonly Task<GateStatus> loginStatusTask;
+        private bool refetchLoginStatus = false;
+
         public bool IsLoggingIn;
 
         public Launcher Launcher { get; private set; }
@@ -71,9 +75,36 @@ namespace XIVLauncher.Windows.ViewModel
             LoginNoThirdCommand = new SyncCommand(GetLoginFunc(AfterLoginAction.StartWithoutThird), () => !IsLoggingIn);
             LoginRepairCommand = new SyncCommand(GetLoginFunc(AfterLoginAction.Repair), () => !IsLoggingIn);
 
+            var frontierUrl = Updates.UpdateLease?.FrontierUrl;
+#if DEBUG || RELEASENOUPDATE
+            // FALLBACK
+            frontierUrl ??= "https://launcher.finalfantasyxiv.com/v650/index.html?rc_lang={0}&time={1}";
+#endif
+
             Launcher = App.GlobalSteamTicket == null
-                ? new(App.Steam, App.UniqueIdCache, CommonSettings.Instance, Updates.UpdateLease?.FrontierUrl)
-                : new(App.GlobalSteamTicket, App.UniqueIdCache, CommonSettings.Instance, Updates.UpdateLease?.FrontierUrl);
+                ? new(App.Steam, App.UniqueIdCache, CommonSettings.Instance, frontierUrl)
+                : new(App.GlobalSteamTicket, App.UniqueIdCache, CommonSettings.Instance, frontierUrl);
+
+            // Tried and failed to get this from the theme
+            var worldStatusBrushOk = new SolidColorBrush(Color.FromRgb(0x21, 0x96, 0xf3));
+            WorldStatusIconColor = worldStatusBrushOk;
+
+            // Grey out world status icon while deferred check is running
+            WorldStatusIconColor = new SolidColorBrush(Color.FromRgb(38, 38, 38));
+
+            this.loginStatusTask = Launcher.GetLoginStatus();
+            this.loginStatusTask.ContinueWith((resultTask) =>
+            {
+                try
+                {
+                    var brushToSet = resultTask.Result.Status ? worldStatusBrushOk : null;
+                    WorldStatusIconColor = brushToSet ?? new SolidColorBrush(Color.FromRgb(242, 24, 24));
+                }
+                catch
+                {
+                    // ignored
+                }
+            });
         }
 
         private Action<object> GetLoginFunc(AfterLoginAction action)
@@ -338,7 +369,17 @@ namespace XIVLauncher.Windows.ViewModel
 #if !DEBUG
             try
             {
-                loginStatus = await Launcher.GetLoginStatus().ConfigureAwait(false);
+                if (refetchLoginStatus)
+                {
+                    var response = await Launcher.GetLoginStatus().ConfigureAwait(false);
+                    loginStatus = response.Status;
+                }
+                else
+                {
+                    var response = await this.loginStatusTask;
+                    loginStatus = response.Status;
+                    refetchLoginStatus = true;
+                }
             }
             catch (Exception ex)
             {
@@ -1485,6 +1526,17 @@ namespace XIVLauncher.Windows.ViewModel
             }
         }
 
+        private SolidColorBrush _worldStatusIconColor;
+        public SolidColorBrush WorldStatusIconColor
+        {
+            get => _worldStatusIconColor;
+            set
+            {
+                _worldStatusIconColor = value;
+                OnPropertyChanged(nameof(WorldStatusIconColor));
+            }
+        }
+
         #endregion
 
         #region Localization
diff --git a/src/XIVLauncher/XIVLauncher.csproj b/src/XIVLauncher/XIVLauncher.csproj
index 17fa6690..26d7d592 100644
--- a/src/XIVLauncher/XIVLauncher.csproj
+++ b/src/XIVLauncher/XIVLauncher.csproj
@@ -3,7 +3,7 @@
     <Product>XIVLauncher</Product>
     <AssemblyTitle>XIVLauncher</AssemblyTitle>
     <Description>Custom launcher for the most critically acclaimed MMO.</Description>
-    <VersionPrefix>6.3.10</VersionPrefix>
+    <VersionPrefix>6.3.12</VersionPrefix>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -143,4 +143,4 @@
     <WriteCodeFragment Language="C#" OutputFile="$(CustomAssemblyInfoFile)" AssemblyAttributes="@(AssemblyAttributes)" />
   </Target>
 
-</Project>
\ No newline at end of file
+</Project>
